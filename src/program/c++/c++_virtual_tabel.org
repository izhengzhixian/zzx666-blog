#+TITLE: C++ 虚表分析
#+DATE: <2018-02-03 Sat>
#+LAYOUT: post
#+OPTIONS: ^:{}
#+TAGS: program, C++
#+CATEGORIES: program, c++

* C++ 虚表分析
  当类中存在虚函数时，会在实例化对象时头部增加一个 size(void*)的大小，用来存放虚函数表

  #+BEGIN_EXPORT html
    <!--more-->
  #+END_EXPORT

* 子类调用父类的构造函数
  当在 new 一个子类时，会分配相应内存，然后调用这个子类 c1ev 初始化内存，
  然后这个子类会调用父类，直到最上层的类，最后再一层一层返回，
  返回时，就会设置虚指针为这个类的虚函数表

* g++反汇编时，会出现以 D0Ev，D1Ev，D2Ev 结尾的函数

** 构造函数原理

  ps: gcc 里虚析构函数在虚表里是一对

  complete object destructor, deleting destructor

  D0Ev mangled: 堆对象析构时，调用该版本（即用 delete p 析构时）。

  D1Ev mangled: 位于类层次的最底层，且为栈对象时，调用该版本。

  D2Ev mangled: 位于类层次结构的非底层，即作为基类使用时，调用该版本。

  据我观看汇编代码，得出以下结论

  1. d0ev: 调用 d1ev，并释放内存
  2. d1ev: 执行析构函数，并调用父类析构函数
  3. d2ev: 与 d1ev 一样
  4. c1ev: 入口，对象内存布局，比如一个子类的子类有虚基类，那么 c1ev 就会调用重复类的构造函数
  5. c2ev: 被子类的 c1ev 调用，还是比如虚基类，那么这个就会多接收一个参数，
     包含虚基类的信息（包括地址)

**  析构按以下步骤进行:

   ps: d2ev 中修改类对象虚拟表的地址到当前类的虚拟表地址

   d2ev 与 d1ev 是在 g++，clang++中是别名的关系

   c2ev 与 c1ev 是在 g++，clang++中是别名的关系

   1. 执行当前类写的析构内的内容(d2ev)
   2. if (当前类有父类)

      调用父类的 d2ev

      跳到 2

      else if(需要释放内存，仅限于堆，delete 时)

      调用 d0ev，释放内存（在 d0ev 重调用类 d1ev)

      else if(栈空间释放之前)

      调用 d1ev（执行我们写的析构函数）

* 虚函数表内存空间
  下面每个单元大小是(void*)的大小（从 0 开始的函数地址顺序不一定）

  | 指针索引 |                                              |
  |----------+----------------------------------------------|
  |          |                                              |
  |       -4 | 第二个虚基类偏移（相对于当前类），没有就省略 |
  |       -3 | 第一个虚基类偏移（相对于当前类）             |
  |       -2 | 当前类在子类中的偏移                         |
  |       -1 | typeinfo address（包含父类信息)              |
  |       -1 | typeinfo address（包含父类信息)              |
  |        0 | 虚析构函数 d1ev  （没有就不写)               |
  |        1 | 虚析构函数 d0ev  （没有就不写)               |
  |        2 | ...剩余的虚函数地址                          |

* 执行 delete 虚析构函数时，虚函数表地址会变化
  1. 执行子类析构函数 d0ev，然后调用本类的 d1ev，返回之后，释放内存
  2. d1ev 会让修改对象的虚表指针，最后调用父类 d1ev，跳到 2
  3. d1ev 执行到没有父类时，返回
